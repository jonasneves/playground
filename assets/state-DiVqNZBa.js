const H=i=>{let a;const r=new Set,n=(l,u)=>{const d=typeof l=="function"?l(a):l;if(!Object.is(d,a)){const p=a;a=u??(typeof d!="object"||d===null)?d:Object.assign({},a,d),r.forEach(v=>v(a,p))}},o=()=>a,c={setState:n,getState:o,getInitialState:()=>m,subscribe:l=>(r.add(l),()=>r.delete(l))},m=a=i(n,o,c);return c},E=(i=>i?H(i):H);function j(i,a){let r;try{r=i()}catch{return}return{getItem:o=>{var e;const h=m=>m===null?null:JSON.parse(m,void 0),c=(e=r.getItem(o))!=null?e:null;return c instanceof Promise?c.then(h):h(c)},setItem:(o,e)=>r.setItem(o,JSON.stringify(e,void 0)),removeItem:o=>r.removeItem(o)}}const _=i=>a=>{try{const r=i(a);return r instanceof Promise?r:{then(n){return _(n)(r)},catch(n){return this}}}catch(r){return{then(n){return this},catch(n){return _(n)(r)}}}},R=(i,a)=>(r,n,o)=>{let e={storage:j(()=>window.localStorage),partialize:t=>t,version:0,merge:(t,S)=>({...S,...t}),...a},h=!1,c=0;const m=new Set,l=new Set;let u=e.storage;if(!u)return i((...t)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),r(...t)},n,o);const d=()=>{const t=e.partialize({...n()});return u.setItem(e.name,{state:t,version:e.version})},p=o.setState;o.setState=(t,S)=>(p(t,S),d());const v=i((...t)=>(r(...t),d()),n,o);o.getInitialState=()=>v;let g;const w=()=>{var t,S;if(!u)return;const I=++c;h=!1,m.forEach(s=>{var f;return s((f=n())!=null?f:v)});const y=((S=e.onRehydrateStorage)==null?void 0:S.call(e,(t=n())!=null?t:v))||void 0;return _(u.getItem.bind(u))(e.name).then(s=>{if(s)if(typeof s.version=="number"&&s.version!==e.version){if(e.migrate){const f=e.migrate(s.state,s.version);return f instanceof Promise?f.then(b=>[!0,b]):[!0,f]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,s.state];return[!1,void 0]}).then(s=>{var f;if(I!==c)return;const[b,O]=s;if(g=e.merge(O,(f=n())!=null?f:v),r(g,!0),b)return d()}).then(()=>{I===c&&(y?.(g,void 0),g=n(),h=!0,l.forEach(s=>s(g)))}).catch(s=>{I===c&&y?.(void 0,s)})};return o.persist={setOptions:t=>{e={...e,...t},t.storage&&(u=t.storage)},clearStorage:()=>{u?.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>w(),hasHydrated:()=>h,onHydrate:t=>(m.add(t),()=>{m.delete(t)}),onFinishHydration:t=>(l.add(t),()=>{l.delete(t)})},e.skipHydration||w(),g||v},F=R;export{E as c,F as p};
